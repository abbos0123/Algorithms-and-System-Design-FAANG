class Solution {
        private int count;
    public long countPairs(int n, int[][] edges) {
        Map<Integer, List<Integer>> graph = new HashMap<>();

        for (int[] edge : edges) {
            if (graph.containsKey(edge[0])) {
                List<Integer> exist = graph.get(edge[0]);
                exist.add(edge[1]);
                graph.put(edge[0], exist);
            } else graph.put(edge[0], new ArrayList<>(Arrays.asList(edge[1])));

            if (graph.containsKey(edge[1])) {
                List<Integer> exist = graph.get(edge[1]);
                exist.add(edge[0]);
                graph.put(edge[1], exist);
            } else graph.put(edge[1], new ArrayList<>(Arrays.asList(edge[0])));
        }


        int connected = 0;
        List<Integer> components = new ArrayList<>();

        int[] visited = new int[n];
        for (int i = 0; i < n; ++i) {
            if (visited[i] == 0) {
                connected++;
                count = 0;
                DFS(i, graph, visited);
                components.add(count);
            }
        }

        long ans = 0;
        long sum = 0;

        for (int c : components) {
            sum += c;
            ans += (long) c * (n - sum);
        }

        return ans;
    }

    private void DFS(int start, Map<Integer, List<Integer>> graph, int[] visited) {
        visited[start] = 1;
        count++;
        for (int i = 0; i < (graph.containsKey(start) ? graph.get(start).size() : 0); ++i) {
            if (visited[(graph.get(start).get(i))] == 0)
                DFS(graph.get(start).get(i), graph, visited);
        }
    }
}
